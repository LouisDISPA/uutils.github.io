<!DOCTYPE html>
<html>
  <head>
    <title>uutils - gsoc</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="style.css" rel="stylesheet">
  </head>
  <body>
    <h1 id="what-is-google-summer-of-code">Uutils at the gsoc</h1>
    <p>Google summer of code is:</p>
    <blockquote>
      <p>Google Summer of Code is a global, online program focused on bringing
        new contributors into open source software development. GSoC
        Contributors work with an open source organization on a 12+ week
        programming project under the guidance of mentors.
      </p>
    </blockquote>
    <p>If you want to know more about how it works, check out the links
      below.
    </p>
    <strong>Useful links</strong>:
    <ul>
      <li> <a
        href="https://google.github.io/gsocguides/student/">GSOC Contributor
        Guide</a>
      </li>
      <li> <a
        href="https://developers.google.com/open-source/gsoc/faq">GSOC FAQ</a></li>
      <li>
        <a href="https://developers.google.com/open-source/gsoc/timeline">GSOC
        Timeline</a> (important for deadlines!)
      </li>
    </ul>
    <h1 id="what">What is it about?</h1>
    <p>The <a href="https://github.com/uutils/">uutils project</a> is aiming at rewriting key Linux utilities in Rust, targeting <a href="https://github.com/uutils/coreutils">coreutils</a>, <a href="https://github.com/uutils/findutils">findutils</a>, <a href="https://github.com/uutils/diffutils">diffutils</a>, <a href="https://github.com/uutils/procps">procps</a>, <a href="https://github.com/uutils/util-linux">util-linux</a>, and <a href="https://github.com/uutils/bsdutils">bsdutils</a>. Their goal is to create fully compatible, high-performance drop-in replacements, ensuring reliability through upstream test suites. Significant progress has been made with coreutils, diffutils, and findutils, while the other utilities are in the early stages of development.</p>
      </p>
    </h1>
    <h1 id="how-to-get-started">How to get started</h1>
    <p>Here are some steps to follow if you want to apply for a GSOC project
      with uutils.
    </p>
    <ol start="0" type="1">
      <li><strong>Check the requirements.</strong> You have to meet <a
        href="https://developers.google.com/open-source/gsoc/faq#what_are_the_eligibility_requirements_for_participation">Google's
        requirements</a> to apply. Specifically for uutils, it's best if you at
        least know some Rust and have some familiarity with using the
        coreutils and the other tools.
      </li>
      <li>
        <strong>Reach out to us!</strong> We are happy to discuss potential
        projects and help you find a meaningful project for uutils. Tell us what
        interests you about the project and what experience you have and we can
        find a suitable project together. You can talk to the uutils maintainers
        on the <a href="https://discord.gg/wQVJbvJ">Discord server</a>. In
        particular, you can contact:
        <ul>
          <li>Sylvestre Ledru (<span class="citation"
            data-cites="sylvestre">@sylvestre</span> on GitHub and Discord)</li>
          <li>Terts Diepraam (<span class="citation"
            data-cites="tertsdiepraam">@tertsdiepraam</span> on GitHub and <span
            class="citation" data-cites="terts">@terts</span> on Discord)</li>
        </ul>
      </li>
      <li><strong>Get comfortable with uutils.</strong> To find a good project
        you need to understand the codebase. We recommend that you take a look
        at the code, the issue tracker and tackle some <a
          href="https://github.com/uutils/coreutils/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22">good-first-issues</a>.
        Also take a look at our <a
          href="https://github.com/uutils/coreutils/blob/main/CONTRIBUTING.md">contributor
        guidelines</a>.<br />We expect you to <b>fix a few good first bugs</b> to be selected.
      </li>
      <li><strong>Find a project and a mentor.</strong> In this page, we have a list
        of potential projects you can adapt or use as inspiration. Make sure
        discuss your ideas with the maintainers! Some project ideas below have
        suggested mentors you could contact.
      </li>
      <li><strong>Write the application.</strong> You can do this with your
        mentor. The application has to go through Google, so make sure to follow
        all the advice in Google's <a
          href="https://google.github.io/gsocguides/student/writing-a-proposal">Contributor
        Guide</a>.
      </li>
    </ol>
    <h1 id="tips">Tips</h1>
    <ul>
      <li>Make sure the project is concrete and well-defined.</li>
      <li>Communication is super important!</li>
      <li>Try to tackle some simple issues to get familiar with uutils.</li>
    </ul>
    <h1 id="project-ideas">Project Ideas</h1>
    <p>This page contains project ideas for the Google Summer of Code for
      uutils. Feel free to suggest project ideas of your own.
    </p>
    <p><a
      href="https://google.github.io/gsocguides/mentor/defining-a-project-ideas-list">Guidelines
      for the project list</a>
    </p>
    <p>Summarizing that page, each project should include:
        <ul>
    <li><strong>Title</strong></li>
    <li><strong>Description</strong></li>
    <li><strong>Expected outputs</strong></li>
    <li><strong>Skills required/preferred</strong></li>
    <li><strong>Possible mentors</strong></li>
    <li><strong>Size</strong> (either ~175 or ~350 hours)</li>
    <li><strong>Difficulty</strong> (easy, medium, or hard)</li>
</ul>
    </p>
    <h2 id="implement-stty">Implement <code>stty</code></h2>
    <p>The <code>stty</code> utility is currently only partially implemented
      and should be expanded.
    </p>
    <p>See issues: <a
      href="https://github.com/uutils/coreutils/issues/3859">#3859</a>, <a
      href="https://github.com/uutils/coreutils/issues/3860">#3860</a>, <a
      href="https://github.com/uutils/coreutils/issues/3861">#3861</a>.</p>
    <ul>
      <li>Difficulty: Medium</li>
      <li>Size: 175 or 350 depending on the scope</li>
      <li>Mentors: Terts Diepraam</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
          <li>Basic knowledge about the terminal</li>
        </ul>
      </li>
    </ul>
    <h2 id="localization">Localization</h2>
    <p>Support for localization for formatting, quoting &amp; sorting in
      various utilities, like <code>date</code>, <code>ls</code> and
      <code>sort</code>. For this project, we need to figure out how to deal
      with locale data. The first option is to use the all-Rust
      <code>icu4x</code> library, which has a different format than what
      distributions usually provide. In this case a solution <em>could</em> be
      to write a custom <code>localedef</code>-like command. The second option
      is to use a wrapper around the C <code>icu</code> library, which comes
      with the downside of being a C dependency.
    </p>
    <p>This is described in detail in <a
      href="https://github.com/uutils/coreutils/issues/3997">issue
      #3997</a>.
    </p>
    <p>And was also discussed in <a
      href="https://github.com/uutils/coreutils/issues/1919#issuecomment-846471073">#1919</a>,
      <a href="https://github.com/uutils/coreutils/issues/3584">#3584</a>.
    </p>
    <ul>
      <li>Difficulty: Hard</li>
      <li>Size: TBD</li>
      <li>Mentors: TBD</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
        </ul>
      </li>
    </ul>
<h2 id="process-management">Development of Process Management and Information Tools in Rust</h2>
<p>This project focuses on creating Rust-based implementations of process management and information tools: <b>ps</b>, <b>pgrep</b>, <b>pidwait</b>, <b>pkill</b>, <b>skill</b>, and <b>snice</b>. The goal is to ensure full compatibility with all options and successful passing of GNU tests, maintaining the functionality and reliability of these essential tools.</p>
<ul>
    <li><strong>Description:</strong> Develop Rust-based versions of key process management and information tools, ensuring compatibility with all options and GNU tests.</li>
    <li><strong>Expected Outputs:</strong> Efficient, reliable tools with full option compatibility and passing GNU tests.</li>
    <li><strong>Skills Required/Preferred:</strong> Proficiency in Rust, understanding of Linux process management, experience with GNU testing methodologies.</li>
    <li><strong>Possible Mentors:</strong> [To be determined]</li>
    <li><strong>Size:</strong> ~350 hours.</li>
    <li><strong>Difficulty:</strong> Medium.</li>
</ul>
<h2 id="system-monitoring">Development of System Monitoring and Statistics Tools in Rust</h2>
<p>This project involves the Rust-based development of system monitoring and statistics tools: <b>top</b>, <b>vmstat</b>, <b>tload</b>, <b>w</b>, and <b>watch</b>. The objective is to achieve full compatibility with all options and to pass GNU tests, ensuring these tools provide accurate and reliable system insights.</p>
<ul>
    <li><strong>Description:</strong> Create Rust versions of system monitoring and statistics tools, with a focus on full option compatibility and passing GNU tests.</li>
    <li><strong>Expected Outputs:</strong> Robust tools for system monitoring and statistics, fully compatible with existing options and verified by GNU tests.</li>
    <li><strong>Skills Required/Preferred:</strong> Rust expertise, knowledge of system performance metrics, familiarity with GNU testing frameworks.</li>
    <li><strong>Possible Mentors:</strong> [To be determined]</li>
    <li><strong>Size:</strong> ~350 hours.</li>
    <li><strong>Difficulty:</strong> Medium.</li>
</ul>
<h2 id="memory-resource-analysis">Development of Memory and Resource Analysis Tools in Rust</h2>
<p>The aim of this project is to develop Rust-based versions of memory and resource analysis tools: <b>pmap</b> and <b>slabtop</b>. The project will focus on ensuring full compatibility with all options and passing GNU tests, providing in-depth and reliable analysis of memory usage and kernel resources.</p>
<ul>
    <li><strong>Description:</strong> Implement Rust versions of memory and resource analysis tools, with emphasis on option compatibility and passing GNU tests.</li>
    <li><strong>Expected Outputs:</strong> Advanced tools for memory and resource analysis, fully compatible with existing options and validated by GNU tests.</li>
    <li><strong>Skills Required/Preferred:</strong> Proficiency in Rust, deep understanding of memory management and kernel resources, experience with GNU testing methodologies.</li>
    <li><strong>Possible Mentors:</strong> [To be determined]</li>
    <li><strong>Size:</strong> ~350 hours.</li>
    <li><strong>Difficulty:</strong> Hard.</li>
</ul>


<h2 id="better-gnu-test-reports">Code refactoring for procps, util-linux, and bsdutils</h2>
    <p>Refactoring the Rust-based versions of procps, util-linux, and bsdutils to reduce code duplication.
    </p>
<ul>
    <li><strong>Title:</strong> Code Optimization and Refactoring for procps, util-linux, and bsdutils in Rust</li>
    <li><strong>Description:</strong> This project involves optimizing and refactoring the Rust-based versions of procps, util-linux, and bsdutils. The focus will be on eliminating duplicated code across these utilities, particularly in areas like uudoc, the test framework, and support for single/multicall binaries.</li>
    <li><strong>Expected outputs:</strong> A streamlined codebase with reduced duplication, improved maintainability for procps, util-linux, and bsdutils.</li>
    <li><strong>Skills required/preferred:</strong> Proficiency in Rust programming, understanding of Linux utilities, experience with code optimization and refactoring.</li>
    <li><strong>Possible mentors:</strong> Sylvestre</li>
    <li><strong>Size:</strong> 175 hours</li>
    <li><strong>Difficulty:</strong> Medium</li>
</ul>
    </ul>
    <h2 id="a-multicall-binary-and-core-library-for-findutils">A multicall
      binary and core library for <code>findutils</code>
    </h2>
    <p><code>findutils</code> currently exists of a few unconnected
      binaries. It would be nice to have a multicall binary (like
      <code>coreutils</code>) and a library of shared functions (like
      <code>uucore</code>).
    </p>
    <p>This also might require thinking about sharing code between coreutils
      and findutils.
    </p>
    <ul>
      <li>Difficulty: Medium</li>
      <li>Size: 175 hours</li>
      <li>Mentors: TBD</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
        </ul>
      </li>
    </ul>
    <h2 id="test-exec">Implementation of GNU Test Execution for procps, util-linux, diffutils, and bsdutils</h2>
    <p>The project aims at integrating the GNU test suite execution using the Rust-based versions of procps, util-linux, diffutils, and bsdutils, ensuring compatibility, crucial for seamless drop-in replacement integration. We have been doing such operation successfully for the Coreutils using <a href="https://github.com/uutils/coreutils/blob/main/.github/workflows/GnuTests.yml">GitHub Actions</a>, a <a href="https://github.com/uutils/coreutils/blob/main/util/build-gnu.sh">build script</a> and a <a href="https://github.com/uutils/coreutils/blob/main/util/run-gnu-test.sh">run script</a>.
    </p>
<ul>
    <li><strong>Description:</strong> Run the GNU test suite on the Rust-based versions of procps, util-linux, diffutils, and bsdutils</li>
    <li><strong>Expected Outputs:</strong> The GNU test suite execution for each utility, ensuring functionality meets expected standards</li>
    <li><strong>Skills Required/Preferred:</strong> GitHub action understanding, Proficiency in Rust, experience with GNU testing methodologies, familiarity with Linux system utilities, and understanding of software testing principles.</li>
    <li><strong>Possible Mentors:</strong> Sylvestre</li>
    <li><strong>Size:</strong> ~175 hours</li>
    <li><strong>Difficulty:</strong> Medium</li>
</ul>
    <h2 id="refactoring-factor">Refactoring <code>factor</code></h2>
    <p>The uutils <code>factor</code> is currently significantly slower than
      GNU <code>factor</code> and only supports numbers up to 2^64-1. See <a
        href="https://github.com/uutils/coreutils/issues/1559">issue 1559</a>
      and <a href="https://github.com/uutils/coreutils/issues/1456">issue
      1456</a> for more information.
    </p>
    <ul>
      <li>Difficulty: Hard</li>
      <li>Size: 175 hours</li>
      <li>Mentors: TBD</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
          <li>Optimization techniques</li>
          <li>Mathematics</li>
        </ul>
      </li>
    </ul>
    <h2
      id="symbolicfuzz-testing-and-formal-verification-of-tool-grammars">Symbolic/Fuzz
      Testing and Formal Verification of Tool Grammars
    </h2>
    <p>See <a
      href="https://www.amazon.science/publications/using-lightweight-formal-methods-to-validate-a-key-value-storage-node-in-amazon-s3">Using
      Lightweight Formal Methods to Validate a Key Value Storage Node In
      Amazon S3</a>.
    </p>
    <p>Most KLEE scaffolding was done for <a
      href="https://project-oak.github.io/rust-verification-tools/2021/07/14/coreutils.html">KLEE
      2021</a>.
    </p>
    <p>Start with <code>wc</code>, formalize the command line grammar. Get
      it working under AFL++ and Klee. Add several proofs of resource use and
      correctness - especially proofs about operating system calls and
      memory/cache usage. Generalize to other tools. Try to unify the seeds
      for the fuzzer and KLEE so they can help each other find new paths. Use
      QEMU to test several operating systems and architectures. Automate
      detection of performance regressions - try to hunt for <a
        href="https://accidentallyquadratic.tumblr.com">accidentally
      quadratic</a> behavior.
    </p>
    <p>Specific to <code>wc</code> - formalize the inner loop over a UTF-8
      buffer into a finite state automata with counters that can generalize
      into SIMD width operations like <a
        href="https://simdjson.org">simdjson</a>. Further generalize into a
      monoid so K processors can combine results.
    </p>
    <ul>
      <li>Difficulty: Mixed</li>
      <li>Size: Mixed</li>
      <li>Mentors: TBD - informally <span class="citation"
        data-cites="chadbrewbaker">@chadbrewbaker</span></li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
          <li>KLEE</li>
          <li>Fuzzers like AFL++</li>
          <li>Grammar testing frameworks like <a
            href="https://github.com/ligurio/lark-grammars/tree/master/lark_grammars/grammars">LARK</a></li>
          <li>/usr/bin/time -v (and similar tools for Widows/OSX).</li>
          <li>Alloy, TLA+, <a href="https://github.com/p-org/P">P</a></li>
          <li>System call tracing with <a
            href="https://jvns.ca/blog/2014/02/17/spying-on-ssh-with-strace/">strace</a>,
            <a href="https://github.com/namhyung/uftrace">uftrace</a> etc.
          </li>
          <li>SMT solvers like <a
            href="https://www.philipzucker.com/programming-and-interactive-proving-with-z3py/">Z3</a>
            and CVC5 for superoptimization and proofs of automata equivalence.
          </li>
          <li><a href="https://github.com/google/souper">SOUPER</a> and <a
            href="https://godbolt.org">CompilerExplorer</a></li>
          <li>Basic statistics on quantiles (histograms) for outlier detection.
            The math is simple as generalizing from one to k medians but the formal
            notation is <a
              href="https://aakinshin.net/posts/thdqe-hdi/">complex</a>.
          </li>
          <li><a
            href="https://wgropp.cs.illinois.edu/courses/cs598-s16/lectures/lecture32.pdf">MPI-IO</a>,
            just enough to read a file into k parts and combine 'wc' outputs to
            understand multicore scaling.
          </li>
        </ul>
      </li>
    </ul>
<h2 id="terminal-recording">Development of advanced terminal session recording and replay tools in Rust</h2>
<p>This project involves creating Rust-based implementations of <code>/usr/bin/script</code>, <code>/usr/bin/scriptlive</code>, and <code>/usr/bin/scriptreplay</code>. The <code>/usr/bin/script</code> command will record terminal sessions, <code>/usr/bin/scriptlive</code> will offer real-time recording features, and <code>/usr/bin/scriptreplay</code> will be used to replay recorded sessions.</p>
<p>The work will happen in https://github.com/uutils/bsdutils.
</p>
<ul>
    <li><strong>Description:</strong> Develop Rust-based versions of <code>/usr/bin/script</code>, <code>/usr/bin/scriptlive</code>, and <code>/usr/bin/scriptreplay</code> for terminal session recording and replaying.</li>
    <li><strong>Expected Outputs:</strong> Robust and cross-platform terminal session recording and replay tools, with real-time features in <code>scriptlive</code>.</li>
    <li><strong>Skills Required/Preferred:</strong> Proficiency in Rust, understanding of terminal emulation, experience with cross-platform development.</li>
    <li><strong>Possible Mentors:</strong> [To be determined]</li>
    <li><strong>Size:</strong> ~175 hours</li>
    <li><strong>Difficulty:</strong> Medium</li>
</ul>

<h2 id="official-redox-support">Official Redox support</h2>
    <p>We want to support the Redox operating system, but are not actively
      testing against it. Since the last round of fixes in <a
        href="https://github.com/uutils/coreutils/pull/2550">#2550</a>, many
      changes have probably been introduced that break Redox support. This
      project would involve setting up Redox in the CI and fixing any issues
      that arise and porting features over.
    </p>
    <ul>
      <li>Difficulty: Medium</li>
      <li>Size: 175 hours</li>
      <li>Mentors: TBD</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
        </ul>
      </li>
    </ul>
    <h2 id="port-gnus-parse_datetime">Port GNU's
      <code>parse_datetime</code>
    </h2>
    <p>GNU coreutils has a particularly complex function called
      <code>parse_datetime</code>, which parses absolute and relative date and
      time according to the rules specified <a
        href="https://www.gnu.org/software/coreutils/manual/html_node/Date-input-formats.html">in
      the documentation</a>. We currently only support a small subset of the
      formats that GNU's <code>parse_datetime</code> supports. This function
      is used for the <code>-d</code> option of <code>touch</code> and as
      input to <code>date</code>.
    </p>
    <p>At the end of the project, there should be a module (or crate) with a
      fully compatible datetime parser with an extensive test suite.
    </p>
    <p>See <a href="https://github.com/uutils/coreutils/pull/4193">PR
      4193</a> and <a
        href="https://github.com/uutils/coreutils/blob/6a9660f9f64c44db85ee2c130d892946d78781ab/src/uu/touch/src/touch.rs#L334"><code>parse_date</code>
      in <code>touch</code></a>
    </p>
    <ul>
      <li>Difficulty: Hard</li>
      <li>Size: ~175 hours</li>
      <li>Mentors: TBD</li>
      <li>
        Required skills:
        <ul>
          <li>Rust</li>
          <li>Parsing</li>
        </ul>
      </li>
    </ul>
  </body>
</html>
